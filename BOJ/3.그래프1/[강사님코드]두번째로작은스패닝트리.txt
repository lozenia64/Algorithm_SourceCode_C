#include <stdio.h>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;
#define KMAX 16
int INF = (1ll<<31)-1;
int V,E;
struct edge{
    int from,to,cost,used;
    bool operator<(const edge & ref )const{
        return cost<ref.cost;
    }
}M[200001];
int root[50001];
int depth[50001];
int parent[KMAX+1][50001];
int maxLen[KMAX+1][50001];
int smaxLen[KMAX+1][50001];
int edges[100001];
vector<int> adj[50001], adjv[50001];
int group(int node)
{
    if(root[node] == node) return node;
    else return root[node] = group(root[node]);
}
void join(int a, int b)
{
    root[group(b)] = group(a);
}
int max(int a, int b){return (a>b?a:b);}
int main(){
    scanf("%d%d",&V,&E);
    for(int i=0;i<=V;i++)
    {
        depth[i] = -1;
        root[i] = i;
        adj[i].clear();
        adjv[i].clear();
        for(int k=0;k<=KMAX;k++)
        {
            parent[k][i]=0;
            maxLen[k][i] = smaxLen[k][i] = -1;
        }
    }
    for(int i=0;i<E;i++)
    {
        scanf("%d%d%d",&M[i].from,&M[i].to,&M[i].cost);
        M[i].used = 0;
    }

    sort(M,M+E);
    int mst_cost=0, mst_cnt=0;
    for(int i=0;i<E;i++)
    {
        if(group(M[i].from) != group(M[i].to))
        {
            M[i].used = 1;
            join(M[i].from,M[i].to);
            mst_cost += M[i].cost;
            adj[M[i].from].push_back(M[i].to);
            adjv[M[i].from].push_back(M[i].cost);
            adj[M[i].to].push_back(M[i].from);
            adjv[M[i].to].push_back(M[i].cost);
            mst_cnt++;
            if(mst_cnt == V-1) break;
        }
    }
    if(mst_cnt != V-1)
    {
        printf("-1");
        return 0;
    }
    queue <int> que;
    que.push(1);
    depth[1] = 0;
    parent[0][1]=1;
    while(!que.empty())
    {
        int node = que.front();que.pop();
        int size = adj[node].size();
        for(int i=0;i<size;i++)
        {
            int nnode = adj[node][i];
            int cost = adjv[node][i];
            if(depth[nnode]==-1)
            {
                depth[nnode] = depth[node]+1;
                parent[0][nnode] = node;
                maxLen[0][nnode] = cost;
                smaxLen[0][nnode] = -1;
                que.push(nnode);
            }
        }
    }

    int tmpLen[4];
    for(int k=1;k<=KMAX;k++)
    {
        for(int n=1;n<=V;n++)
        {
            parent[k][n] = parent[k-1][parent[k-1][n]];

            tmpLen[0] = maxLen[k-1][n];
            tmpLen[1] = smaxLen[k-1][n];
            tmpLen[2] = maxLen[k-1][parent[k-1][n]];
            tmpLen[3] = smaxLen[k-1][parent[k-1][n]];

            int mmax = -1;
            for(int i=0;i<4;i++) mmax = max(mmax,tmpLen[i]);
            int smax = -1;
            for(int i=0;i<4;i++) if(mmax > tmpLen[i]) smax = max(smax,tmpLen[i]);

            maxLen[k][n] = mmax;
            smaxLen[k][n] = smax;
        }   
    }
    int minGap = INF;
    for(int i=0;i<E;i++)
    {
        if(M[i].used == 0)
        {
            int maxL=-1;
            int a,b, ecnt=0;
            if(depth[M[i].from] < depth[M[i].to])
            {
                a = M[i].from;
                b = M[i].to;
            }
            else
            {
                a = M[i].to;
                b = M[i].from;
            }
            int gap = depth[b] - depth[a];
            for(int k=0;k<=KMAX && gap > 0;k++)
            {
                if(gap%2==1)
                {
                    edges[ecnt++] = maxLen[k][b];
                    edges[ecnt++] = smaxLen[k][b];
                    b = parent[k][b];
                }
                gap/=2;
            }
            /*
            for(int k=KMAX;k>=0 && depth[a] != depth[b];k--)
            {
                if(depth[a] <= depth[parent[k][b]])
                {
                    edges[ecnt++] = maxLen[k][b];
                    edges[ecnt++] = smaxLen[k][b];
                    b = parent[k][b];
                }
            }
            */
            for(int k=KMAX;k>=0 && a!=b;k--)
            {
                if(parent[k][a] != parent[k][b])
                {
                    edges[ecnt++] = maxLen[k][a];
                    edges[ecnt++] = smaxLen[k][a];
                    edges[ecnt++] = maxLen[k][b];
                    edges[ecnt++] = smaxLen[k][b];
                    a = parent[k][a];
                    b = parent[k][b];
                }
            }
            if(a!=b)
            {
                edges[ecnt++] = maxLen[0][a];
                edges[ecnt++] = maxLen[0][b];
            }
            maxL = -1;
            for(int e=0;e<ecnt;e++)
            {
                if(edges[e] > -1 && edges[e] < M[i].cost && maxL < edges[e]) maxL = edges[e];
            }
            if(maxL > -1 && minGap > M[i].cost - maxL) minGap = M[i].cost - maxL;
        }
    }
    //printf("mst[%lld] minGap[%lld]",mst_cost,minGap);
    if(minGap != INF) printf("%d",mst_cost+minGap);
    else printf("-1");
    return 0;
}